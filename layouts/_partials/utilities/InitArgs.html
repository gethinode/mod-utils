<!-- 
    Copyright Â© 2024 - 2025 The Hinode Team / Mark Dumay. All rights reserved.
    Use of this source code is governed by The MIT License (MIT) that can be found in the LICENSE file.
    Visit gethinode.com/license for more details.
-->

{{ $error := false }}
{{ $errorMsg := slice }}
{{ $warnMsg := slice }}

{{ $structure := .structure }}
{{ $named := .named | default true }}
{{ if not $structure }}
    {{- $errorMsg = $errorMsg | append (printf "partial [utilities/InitArgs.html] - Missing value for param 'structure'") -}}
    {{ $error = true }}
{{ end }}

{{ $args := .args | default dict }}
{{ $params := dict }}
{{ $definitions := dict }}
{{ $references := index (index site.Data.structures "_arguments") "arguments" }}
{{ $types := index (index site.Data.structures "_types") "types" }}

{{ $core := (index site.Data.structures $structure).arguments | default dict }}
{{ range $key, $def := $core }}
    {{ with index $references $key }}
        {{ if $def }}
            {{ $definitions = merge $definitions (dict $key (merge . $def)) }}
        {{ else }}
            {{ $definitions = merge $definitions (dict $key .) }}
        {{ end }}
    {{ else }}
        {{ $definitions = merge $definitions (dict $key $def) }}
    {{ end }}
{{ end }}

{{ range $key, $def := $definitions }}
    {{ if not $def.type }}
        {{- $errorMsg = $errorMsg | append (printf "partial [utilities/InitArgs.html] - Missing type for '%s' in '%s'" $key $structure) -}}
        {{ $error =  true }}
    {{ end }}
{{ end }}

{{ $child := .child }}
{{ if $child }}
    {{ $extra_def := (index site.Data.structures $child).arguments }}
    {{ if not $extra_def }}
        {{- $errorMsg = $errorMsg | append (printf "partial [utilities/InitArgs.html] - Missing definitions: %s" $child) -}}
        {{ $error =  true }}
    {{ else }}
        {{ range $key, $val := $extra_def }}
            {{ if and $val $val.parent }}{{ $definitions = merge (dict $key $val) $definitions }}{{ end }}
        {{ end }}
    {{ end }}
{{ end }}

{{ $group := .group }}

{{ define "_partials/inline/type-def.html" }}
    {{ $key := .key }}
    {{ $def := "" }}
    {{ if eq (printf "%T" .key) "string" }}
        {{ $def = index .definitions .key }}
    {{ else }}
        {{ range $k, $d := .definitions }}
            {{ if eq $d.position $key }}
                {{ $def = $d }}{{ $key = $k }}
            {{ end }}
        {{ end }}
    {{ end }}

    {{ return (dict "key" $key "def" $def) }}
{{ end }}

{{ define "_partials/inline/alias-type.html" }}
    {{ $aliases := dict "path" "string" "select" "string" "url" "string" "dict" "[]map[string]interface {}" "slice" "[]interface {}" }}
    {{ $reserved := slice "bool" "int" "int64" "float" "float64" "string" "dict" "slice" }}
    {{ $custom := .types }}
    {{ $references := .references }}

    {{ $types := slice }}
    {{ if not .type }}
        {{ errorf "expected type argument: %s" page.File }}
    {{ else }}
        {{ $types = slice .type }}
    {{ end }}

    {{ $extra := slice }}
    {{ range $types }}
        {{ $alias := index $aliases . }}
        {{ if $alias }}{{ $extra = $extra | append $alias }}{{ end }}
        {{ if not (in $reserved .) }}
            {{ $type := index $custom . }}
            {{ if $type }}
                {{ range $k, $v := $type }}
                    {{ if eq (printf "%T" $k) "string"}}
                        {{ if not (index $references $k) }}
                            {{ errorf "cannot find type definition for '%s.%s'" $.type $k }}
                        {{ end }}
                    {{ else }}
                        {{ range $nk, $nv := $v }}
                            {{ if not (index $references $nk) }}
                                {{ errorf "cannot find type definition for '%s.%s'" $.type $nk }}
                            {{ end }}
                        {{ end }}
                    {{ end }}
                {{ end }}
            
                {{ $extra = $extra | append (printf "%T" $type) }}
            {{ end }}
        {{ end }}
    {{ end }}
    {{ if $extra }}{{ $types = $types | append $extra }}{{ end }}

    {{ return $types }}
{{ end }}

{{ if not $error }}
    {{ range $key, $val := $args }}
        {{ $result := partial "inline/type-def.html" (dict "definitions" $definitions "key" $key) }}
        {{ $def := $result.def }}
        {{ $name := $result.key }}
        {{ if $def }}
            {{ $groups := slice | append $def.group }}
            {{ if and $group $def.group }}
                {{ if not (in $groups $group )}}{{ $def = "" }}{{ end }}
            {{ end }}
        {{ end }}

        {{ if not $def }}
            {{ if eq (printf "%T" $name) "string" }}
                {{ $errorMsg = $errorMsg | append (printf "[%s] unsupported argument '%s'" $structure $name) }}
            {{ else if eq (printf "%T" $name) "int" }}
                {{ $errorMsg = $errorMsg | append (printf "[%s] unsupported argument at index %d (value: '%s')" $structure $name $val) }}
            {{ else }}
                {{ $errorMsg = $errorMsg | append printf ("[%s] unsupported argument value '%s'" $structure $val) }}
            {{ end }}
            {{ $error = true }}
        {{ else }}
            {{ if and (eq $val nil) $def.default }}
                {{ $val = $def.default }}
            {{ end }}

            {{/* validate type */}}
            {{ $expected := partial "inline/alias-type.html" (dict "type" $def.type "types" $types "references" $references) }}
            {{ $actual := printf "%T" $val }}

            {{/* cast supported types from/to string */}}
            {{ if and (in $expected "bool") (in (slice "true" "false") $val) }}
                {{ $actual = "bool" }}
            {{ else if and (in $expected "int") (findRE `^-?\d+$` $val) }}
                {{ $actual = "int" }}
            {{ else if and (in $expected "float") (findRE `^(?:[1-9]\d*|0)?(?:\.\d+)?$` $val) }}
                {{ $actual = "float" }}
            {{ else if and (in $expected "string") (in (slice "bool" "int" "int64" "float" "float64") $actual) }}
                {{ $actual = "string" }}
                {{ $val = string $val }}
            {{ end }}

            {{ if and $val (not (in $expected $actual)) }}
                {{ $errorMsg = $errorMsg | append (printf "[%s] argument '%s': expected type '%s', got '%s'" $structure (string $name) (delimit $expected ", ") $actual) }}
                {{ $error = true }}
            {{ end }}

            {{/* validate permitted values */}}
            {{ if and $def.options.values (eq $actual "string") }}
                {{ if and $val (not (in $def.options.values $val)) }}
                    {{ $errorMsg = $errorMsg | append (printf "[%s] argument '%s': unexpected value '%s'" $structure (string $name) $val) }}
                    {{ $error = true }}
                {{ end }}
            {{ else if and (or $def.options.min $def.options.max) (in (slice "int" "float" "float64") $actual) }}
                {{ if or 
                    (and $def.options.min (lt $val $def.options.min))
                    (and $def.options.max (gt $val $def.options.max))
                }}
                    {{ $min := (string (or $def.options.min "-")) }}
                    {{ $max := (string (or $def.options.max "-")) }}
                    {{ $errorMsg = $errorMsg | append (printf "[%s] argument '%s': value '%s' out of range [%s, %s]" $structure (string $name) (string $val) $min $max) }}
                    {{ $error = true }}
                {{ end }}            
            {{ end }}
        {{ end }}

        {{/* append the argument to the return set */}}
        {{ if not $error }}
            {{ $params = merge $params (dict $name $val) }}
        {{ end }}
    {{ end }}
    
    {{/* validate required and deprecated arguments */}}
    {{ $max := len $args }}
    {{ $expected := 0 }}
    {{ range $key, $val := $definitions }}
        {{ $skip := false }}
        {{ $groups := slice | append $val.group }}
        {{ if and $group $val.group }}
            {{ $skip = not (in $groups $group )}}
        {{ end }}

        {{ if and (not $skip) (not $val.optional) }}
            {{ if $named }}
                {{ if not (isset $args $key) }}
                    {{ $errorMsg = $errorMsg | append (printf "[%s] argument '%s': expected value" $structure $key) }}
                    {{ $error = true }}
                {{ end }}
            {{ else }}
                {{ $expected = add $expected 1 }}
            {{ end }}
        {{ end }}

        {{ with $val.deprecated }}
            {{ if and $named (isset $args $key) }}
                {{ $warn := printf "[%s] argument '%s': deprecated in v%s" $structure $key (strings.TrimPrefix "v" .) }}
                {{ with $val.alternative }}
                    {{ $warn = printf "%s, use '%s' instead" $warn . }}
                {{ end }}
                {{ $warnMsg = $warnMsg | append $warn }}
            {{ end }}
        {{ end }}
    {{ end }}

    {{ if lt $max $expected }}
        {{ $errorMsg = $errorMsg | append (printf "[%s] expected '%d' args, got '%d'" $structure $expected $max) }}
        {{ $error = true }}
    {{ end }}

    {{/* add missing keys with default values or empty collections */}}
    {{ range $key, $val := $definitions }}
        {{ $result := partial "inline/type-def.html" (dict "definitions" $definitions "key" $key) }}
        {{ $def := $result.def }}
        {{ $expected := partial "inline/alias-type.html" (dict "type" $def.type "types" $types "references" $references) }}

        {{ if (not (isset $params $key)) }}
            {{ if (isset $val "default") }}
                {{ $params = merge $params (dict $key $val.default ) }}
            {{ else if (in $expected "map[string]interface {}") }}
                {{ $init := dict }}
                {{ $type := index $types $val.type }}
                {{ range $k, $ignore := $type }}
                    {{ $ref := index $references $k }}
                    {{ if $ref }}{{ with $ref.default }}{{ $init = merge $init (dict $k .) }}{{ end }}{{ end }}
                {{ end }}
                {{ $params = merge $params (dict $key $init) }}
            {{ else if (in $expected "[]map[string]interface {}") }}
                {{ $params = merge $params (dict $key dict) }}
            {{ else if (in $expected "[]interface {}") }}
                {{ $params = merge $params (dict $key slice) }}
            {{ end }}
        {{ end }}
    {{ end }}
{{ end }}

{{ $params = merge $params (dict "err" $error "errmsg" $errorMsg "warnmsg" $warnMsg) }}

{{ return $params }}